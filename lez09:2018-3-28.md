---
author: Gabriele Zarcone
date: 28 marzo 2018
title: Object Orientation
---
---------------------------------------------
# Associazioni

LA seconda delle relazioni che vediamo; ci sono diverse relazioni (generalizzazione, associazioni...)

è una relazione tra istanze di classi, non tra classi -> != generalizzazione

un istanza deve riconoscere e ricordare un altra istanza. Studenti sono in relazione con bellettini, non con tutto il genere dei professore. Siamo associati con un istanza e non con una clsse

Implica una relazione usa. Devo tenere traccia di un altra istanza perchè devo usare le sue funzioni

Quando due oggetti interagiscono vuol dire che c'è una relazione

Un associazione è la più smeplice tra tutte
**In UML:**

> la indico come una linea semplice, con:
>
>> **label**: nome della relazione (Es: segue_corso_di)
>
>> **ruolo**: è utile quando sono associazioni tra due classi uguali. Lo useremo per dare dei nomi agli attributi
>
>> **moltiplicità**: indica quante istanze di una sono in relazione con con quante istanze dell'altra e viceversa. La molteplicità lontana alla classe si riferisce a quella classe lontana.

## Navigabilità associazioni

delle associazioni non sempre sono a doppio senso. Spesso una istanza deve conoscere l'istanza dell'altra ma può non essere necessario il viceversa. 

ES:_ il professore non sa le istanze singole dei suoi studenti.

Qundo progetto devo decidere quali istanze devo memorizzare

> la linea senza nulla è una associazione bidirezionale

> se ho una freccia non piena (->) invece le istanze sono in associazione ma quella che punta deve conoscere e ricordare quella puntata, ma quella puntata non deve ricordare chi la punta anche se è in relazione con lei.

## Associazioni e attributi

spesso l'associazione si fa attraverso la definizione di un attributo, ma non è l'unico modo. 

Non mi costringe ad usare un attributo. Posso anche farlo in maniera diversa. 

**VICEVERSA** non è vero che ogni volta che ho un attributo in cui ho un associazione

Con gli attributi posso fare anche aggregazione e composizione che sono casi particolari di associazioni.

Non è perforza necessario separare associzione da aagregazione, composizione ecc.. potrei all'inizio mettere solo associazioni e poi in secondo luogo precisare che tipo di associazione.


### Errore

non va segnato in UML sia l'attributo che l'associazione perchè sto ripetendo due volte la stessa cosa. Se metto solo l'attributo o solo l'associazione ottengo lo stesso effetto. Se metto solo la freccia della associazione posso fare quello che voglio per realizzarla, se metto solo l'attributo obbligo a creare un associazione con un attributo.

# Aggregazioni

le associazioni mi serve come una versione generica di "ho bisogno di realazionarmi con qualcuno. HO bisogno di conoscerlo perchè lo uso"

Ci sono dei casi che mi serve qualcosa che è parte di me, che è parte della mia definizione. 

è diverso dalla associazione IS_composed_of. Perchè non esaurisce la mia definizione, ci sono cose proprie dell'oggetto e non delle sue parti. 

è un tipo particolare di associazione, e viene anche lei molto spesso tradotto con un attributo

(vedi appunti)

.....

# Quali classi?

* Entity: i veri e propri oggetti che caratterizzano il dominio applicativo.
* Controllo : gestiscono gli eventi
* Boundary: rappresentano l'interfaccia


Un altro modo per classificare le classi, non proprio dell'informatica:

* concetti
* cose reali
* ruoli e persone
* eventi
* organizzazioni
* posti

sono cose molto diverse tra loro. 

Posso usarle come punto di partenza per scoprire le classi. Ma dovrei richiedere al cliente la cosa. Posso usarlo invece come controlllo. Per vedere se le cose importanti le ho già scritte come classi. Tenendo presente che non deov per forza rappresentare tutte le cose reali. Non mi serve avere l'oggetto della mamma del dipendente, oppure non voglio tutte le info di una bibliotecaria se faccio un sistema per biblioteche. Non mi serve sapere la sua data di nascita ad esempio.

## CRC card

http://c2.com/doc/oopsla89/paper.html

http://www.softstar-inc.com/Download/Intro%20to%20CRC.pdf

più che per identificare le classi è uile per ragionare sulle dipendenze, gli attributi ecc. sulle classi che ho già trovato. Quando poi faccio il gioco, posso trovare delle cose che mi servono in più sulle dipendenze fra le varie classi e capisco cosa le caratterizza. O i metodi che mi aiutano anche a capire come devono interagire le varie classi. 

## Carte

ogni classe ha una carta. Con scritte:

* Responsabilities
* Collaboration

ogni persona prende una carta e si inizia a dialogare. "Io ho bisogno di questo servizio....Io posso darlo.... ecc"

Capisco quali sono le **responsabilità** che ha la mia classe verso le altre classi:  le info che la mia classe si deve memorizzare.

E capisco qualio sono le **collaborazioni** che devo instaurare tra le varie classi e quindi i metodi che devo implementare. 

# Pattern

può aiutare nella fase di modellazione per la decisione delle classi. So già quali classi mi servono per risolvererb il problema.

> Pattern = soluzioni di problemi ricorrenti ripetibili che fornisce un architettura vincente. Sono una soluzione a una famiglia di problemi tutti simili tra loro (per questoi ripetibili)

sono la soluzioni di problemi molto generici che potrebbero capitare a chiunque.

## Anti Pattern

sono le cattive soluzioni ma che sembrano molto ragionevoli. Apparentemente la soluzione sembra essere la migliore ma più si va avanti diventa un'idea pessima, ne rimango invischiato. L'antipattern mi dice: attento che in questa situazione anche se sembra la soluzione più ovvia, guarda che in realtà fa schifo. 

## Idioma

i pattern sono delle soluzioni di come costruisco e modello la mia soluzione ed esula dal linguaggio di programmazione. L'idioma è l'implementazione del pattern per un determinato linguaggio. Viene specificato perchè magari un determinato linguaggio ha un costrutto perfetto per quello che altri non hanno, quindi l'idioma mi consiglia che per quel patter in quel linguaggio si può usare un particolare costrutto di quel linguaggio.

## Quali sono i pattern

Pattern devono essere scritti in maniera chiara. Sono stati decisi che i più importanti sono i 23 della Gang of Four. Che furono i primi a sviluppare dei pattern che usavano per risolvere problemi di grafica, ma che erano tanto generali che andavano bene anche per altre cose.

## Meta Pattern   

astraggo i pattern e guardo cosa sono le componenti principali dei pattern. Ragiono su quali sono i componenti principali dei pattern 

### Hook Method

è la parte a cui mi aggangio al pattern. 

metodo astratto che customizza e rende proprio del mio dominio applicativo il pattern. Scrivo un templete con alcuni punti modificabili così che io possa modificarli e metterci cose del mio dominio applicativo per applicare il pattern alle mie esigenze. Hook sono delle parti di codice non ancora scritte ma che il template già richima. Per questo deve essere astratto: uso del codice che non è ancora stato scritto. Chiamo quel codice anche se nessuno lo ha mai scritto. L'unicino è il riferimento a quella cosa e lo uso come se fosse veramente implementato, quando in realtà viene implementato solamente quando applico il pattern al mio dominio applicativo.

Parte calda = la parte di codice che viene modificata per poter applicare il pattern al mio dominio.

### Template Method

il template invece è il codice che usa gli hook e non viene modificato qunaod voglio usare il pattern. E' tutto ciò che non è hook ma che ingloba gli hook. 

Parte fredda = non viene mai modificato quando applico il pattern. 

#### Relazione hook template

* Unification: nella stessa classe ho hook e template
* Separation: ho due classe separate, hook class e template class e nenache relazionate fra loro
* Connection: sono in classi separate ma sono tra loro in relazione.

# Pattern Gang of Four
sono 23 pattern separati in: 

* Creazionali: per costruire oggetti
* Comportamentali: interazioni tra oggetti, come dialogano tra loro
* Strutturali: composizione di classi di oggetti, come si relazionano e si compongono i vari oggetti


# Observer [COMPORTAMENTALE]

è un pattern molto usato. Fa parte anche di pattern più complessi (devo sempre considerare le relazioni con gli altri pattern). 

Quando ho motle classi che devono reagire al cambiamento di stato di un istanza di un altra classe. Ho un osservato e molti osservatori. Però con una minima conoscenza gli uni degli altri. Non voglio che l'aggiunta di un osservatore o la modifica di un osservatore mi debba costringere a cambiare enormemente l'osservato. Voglio inolre un legame **dinamico**. non definisco chi osserva chi, ma in fase di esecuzione posso modificar chi osserva chi. 

Ci sono diversi modi per ragigiungere qusto scopo:

### Polling

l'osservatore ogni tanto richiede all'osservato informazioni e verifica se ha cambiato o meno il suo stato. Il problema però è che ho una perdita di performance e in più tutti gli osservatori continuerebbero a chiedere all'osservato e l'osservatore impazzisce. Per esempio se tutti i programmi continuano a chiedere alla tastiera se è stato premuto  un tasto, la tastiera impazzirebbe

### Interrupt

Faccio il contrario allora. Il soggetto comunica che è cambito qualcosa. Chiede a chi è interessato al suo stato di registrarsi. Che è registrato riceve la notifica che lo stato è cambiato solamente quando cambia lo stato.  

E' comportamentale perche a fronte di un cambiamento di stato mi determina cosa fare.

* Template = **subject**: rifà sempre le stesse cose e avverte gli observer che è cambiato lo stato
* Hook = **update**: è cosa deve succedere quando cambia lo stato, come deve reagire al cambiamento di stato?

Update è l'uncino al quale il subject si può aggangiare per dirgli ora fai quello che ti serve. Il subject richiama l'update ogni volta che cambia lo stato, ma quello che deve fare l'update non è definito e deve essere specificato dall'utente 

Update e Subject sono in due classi **separate** collegate con un aggregazione.  Aggregazione perchè ci deve essere qualcuno che l'osserva se no non sarebbe un osservato, quando nasce un observer è sempre collegato ad un osservato, quando nasce, vive e muore sta sempre osservando. Ce ne deve essere almeno 1. Se tra subjecg e Observer ho 1-1 vuol dire che quando nasce un Observer allora osserva già qualcosa (osserva sempre qualcosa per tutta la vita). Se metto 0-1 invece posso crearlo indipendentemente da un osservato. Se scelgo uno o l'altro cambia il modo in cui faccio il costruttore(se 1-1 passo l'osservato che dovrà osservare per tutta la vita quando lo creo)

NAvigabilità è da interfacci asubject  a interfaccia observer (Subject conosce l'observer mentre l'obeserver non conosce il subject). Quindi se dico che sono collegati dcon cardinalità 1-1 vuol dire che nel costruttore gli passo un subject sul quale lui si registra (ma non si ricorda a quale subject). Fin dalla sua nascita lo registro a quel subject. In questo modo rispetto nel codice quello che dice il diagramma UML

Ho un'aggregazione fra interfacce ma l'interfaccia non può avere attributi (con il quale di solito sono indicate le aggregazioni). Lo faccio però perchè:

* posso non realizzare l'aggregazione come un attributo
* l'interfaccia è come un contratto con dei metodi da implementare. Così le classi che implementano l'interfaccia dovranno anche implementare questa relazione (lo faccio diventare parte del contratto.)
* con un interfaccia posso creare più tipologie di osservati che comunque sarebbero compatibili con gli osservatori perchè la aggregazione è sull'interfaccia. **dipendo solo dalle cose astratte** (dependecy inversion)

`ConcreteSubject` e `ConcreteObserver` sono le due classi che implementano le interfacce. 

## Scenario d'uso (tratto da HeadFirst)

ho una centralina metereologica con sensori di:

* temperatura
* umidità
* pressione

la centralina esporta un interfaccia software. Ho vari terminali che usando i dati dei tre sensori e le usano in maniera diversa dandomi info diverse (ho un unico dato base e molti usi diversi):

* le previsioni del tempo
* storico
* ....

Oppure potrei avere dei telefonini che mi prendono le info con un app. 

Ho quindi un osservato e un numero indefinito di observer. 

## Template

* `registerObserver()`
* `removeObserver()`
* `notifyObserver()`

essendo la parte fredda non hanno a che fare con la mia implementazione. Saranno sempre uguali per ogni pattern

## Hook

2 *modalità* per fare `update`:

* modalità **PUSH**: l'osservatore riceve contemporaneamente notifica e aggiornamento. Ti notifico che è cambiato lo stato e te lo passo. Va bene solo se il tempo di trasmissione dello stato è gestibile enon troppo lungo (se sono 5GB anche no)
* modalità **PULL**: ti dico solo che è cambiato lo stato e poi sei tu che ti vieni a prendere solo le info dello stato che ti serve e non tutto lo stato. 

a volte si fa ibrido: ti passo un info che serve sempre e poi tu ti puoi andare a prendere anche altro. Così evito che tutti vengano a chiedere le cose che potrei passarli.

Volgio che il pattern siano generici. Quindi le classi devono essere generiche. Non devono sapere nulla di quelle concrete. Nulla di come è fatto lo stato. 

(Lez 10-1)

In modalità Push devo passargli lo stato. Se sono in modalità Pull invece posso anche non passargli niente ma devo far conoscere all'observer chi sono io -(subject) perchè per come abbiamo fatto l'UML l'observer non conosce il subejct (navigabilità aggregazione). Come argomento dell'update quidni passo me stesso. lui non lo sa a priori ma glielo passo ad ogni update. 

## Si conoscono

Altrimenti potrei fasr conoscere il subject all'observer. Ma non faccio una freccia bidirezionale. Ma la direzione tra observer e subject (altra direzione) viene fatta tra oggetti concreti. Perchè devo conoscere come viene implementato. 

## Perchè un interfaccia?

Noi usimao un iterfaccia invece di una classe astratta perchè le classi hanno delle limitazioni. Per esempio se il mio subject concreto esistesse già e fosse un figlio di un altra classe ancora, non potrei farlo diventare figlio anche della classe astratta, mi serve un interfaccia. è figlio di qualcosa ma implementa anche l'interfaccia (si può fare). 

## Java

In Java esiste già una classe astratta Observable che ha già implementato tutto. E un interfaccia Observer che contiene solo update(). All'esame posso usare uno o l'altro. Basta che faccio il grafico giusto. 

Java implementa entrambi i metodi (push & pull). Nei metodi della classe Observasble ci sono entrambi infatti ==> Quelli senza Observer nell'argomento e quelli che non ce l'hanno. 

## NotifyObserver

è un metodo publico. Chiunque può notificare gli osservatori. Anche se non è cambiato lo stato. Così il controllo dell'aggiornamento può essere esterno, non solo quando cambia lo stato ma quando voglio io. Non solo il subject può farlo, ma posso renderlo anche esterno, un qualcosa che aggiorna ogni tot secondi. Aggiungo un metodo `setChanged` che setta una variabile booleana che mi dice se è stato modificato o meno lo stato. Posso così controllare se è stato modificato lo stato e può chiamare o meno la notify. Notify è libero ma funziona solo se la variabile booleana è vera. 

## Update

è l'hook, quello che va effetivamente cambiato. 

```java

```

Controllo prima se l'oggetto che ho passato è effetivamente un istanza di quella classe(`instance_of`). Perchè poi quello che contiene il metodo update non sono metodi genereici, ma sono propri della classe del subject. Non posso guardarlo come un istanza di un oggetto Onservable ma come un oggetto della classe del subject. Se lo è allora faccio un cast alla classe del subject. Devo sapere come è fatta la classe della subject, e quindi dovrei avere una dipendenza tra i due concrete (?)

# Swing 

libreria grafica di Java che ha degli "ascoltatori" che sono tipo degli osservatori. Ho dei listener e ad un bottone posso associare uno o più ascoltatori che reagiscono all'evento del bottone. 

* Observsble = JButton
* Observer = va implementato (actionPerformed) 

* ActionPerformed = hook
* ActionListener = template