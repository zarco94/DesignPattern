---
author: Gabriele Zarcone
date: 22 maggio 2018
title: Verifica e convalida
---
---------------------------------------------

# Test funzionale

è un tet di una black box ===> interpello la black box e vedo come mi risponde

Utile se non conosciamo il codice. 

....

# Software inspection

tecnica manuale per individuare e correggere le anomalie basata su lavoro di gruppo. Come nel ddt in cui il driver guarda senza fare nulla. In quel momento sta facendo Software inspection. E' una metodologia umana ==> posso ragionarci sopra e organizzarla come voglio. Ci sono più persone e quindi più ruoli e può anche essere fatto da un azienda esterna. 

* Moderatore: coordina il meeting e sceglie i partecipanti, controlla il processo (preso solitamente da un altro progetto)
* Readers, Tester: leggono il codice e cercano difetti
* Autore: partecipante passivo. Deve solo rispondere ad eventuali domande. 

## Fasi:

* ..
* **REWORK:**l'autore si occupa dei difetti individuati e li corregge. NB avvine dopo e non durante l'ispezione, non si fa perdere tempo alle altre 5 persone
* **FOLLOW-BACK:** nuova ispezione. Il probnlema è che l'ispezione non riprende la precedente ma ricomincia da capo. 

## Obbiettivo

Non gli interessa il malfunzionamento, ma cerca solamente l'anomalia. Perchè sto guardado solamente il codice senza compilarlo. Voglio trovare il maggior numero di difetti. Senza però correggerli! Perchè si perderebbe tempo. 

L'ispezione non può durare più di 4 ore al giorno (con 2 sessioni da 2 ore) approx 150 linee di codice all'ora. Perchè è un attività comunque provante e le persone che la fanno hanno anche altro da fare. 

## Approccio

parafrasare linea per linea il significato in italiano. Il reader traduce riga per riga in italiano. In modo da risalire allo scopo. 

## CheckList

si fanno delle check list di cose da controllare, perchè so che sono cose che potrebbero portare a problemi.

Sono tutte domande che sono facili da rispondere dal punto di vista umano, ma non è cosiì facile farlo in maniera automatica. 

## Incentivi

* Difetti trovati non devono essere usati per penalizzare il personale.  Il programmatore cercherebbe di boicottare qualunque scoperta. 
* Difetti trovati dopo l'ispezione possono essere usati per la valutazione del personale. Perchè dopo la ispezione dovrebbero non essercene più. Il programmatore quinid è incentivato a trovare tutti i problemi. 

## Osservszioni

un revisore non esperto potrebbe anche non dire nulla, servono dei programmatori esperti. 

## Automatizzare ispezione

* Alcune check list si possono testare automaticamnete. Tipo gli stili di scrittura o i cammel Case.
* Aiuti alla comprensione del codice. Come se fosse un testo ipertestuale posso saltare da una funzione all'altra. 
* Annotazioni e comunicazioni
* Guida al processo e rinforzo. Utile al moderatore per far rispettare le regole. 

## Funziona?

Funziona spesso anche a favore di progettare il test nello stesso tempo di lavoro. si automigliora perchè sfrutta la conoscenza dei lavoratori, che aumenta man mano che lavorano. E' applicabile a programmi incompleti o a cose non formali (es specifiche)

**limiti**: solo 15o righe all'ora. Lavoro solo su una parte piccola e limitata nel numero di limitata di elementi. Devo astrarre a moduli più ad alto livello. In più non è incrementale: devo sempre ricominciare. 

# Tecnica migliore (ispeione VS funzionale VS strutturale)

Nessuna delle 3 tecniche domani su le altre, e soprattutto al massimo posso arrivare a trovare il 50% degli errori se mi va bene e il 30% lo trovo sempre. La cosa migliore quindi è usareli tutti e tre insieme, perchè il loro punto di attacco è diverso. Quindi anche gli errori che trovano sono diversi quindi le loro percentuali si possono sommare. Mettendo tutti e 3 insieme ottengo almeno il 90%. Senza aumentare il tempo di testing, ma dividendo il tempo di testing con diverse tecniche.  

# Debugging

serve per rimuovere le anomalieche sono a causa di malfunzionamenti riscontrati. NOn serve per trovare i malfunzionamenti ma per risolvere le anomalie quando già si conosce il malfunzionamento.

Non è detto che risolvere dei bug mi porta ad averne di meno ma potrei averne di più. 

## Problemi

è difficile trovare la relazioene tra anomalia e funzionamento. Magari il malfunzionamento è dovuto a più anomalie. Un anomalia è necessaria affinche ci sia un malfunzionamento, ma non sufficente. 

## Approcci

* incrementale: permette di limitarela parte in cui ricercare il difetto. 

* Produco stati intermedi del programma

## Tecniche 

### Naïve

Introduco delle `printf()` nel codice che stampino a schermo delle info agiguntive. Il suo punto di forza è che non devo usare nessun tool, ma porta anche inefficenza perchè devo cambiar4e il codice per poterlo controllare. E alla fine devo ripulire tutto. 

### Naïve avanzata

uso dei metodi che qundo faccio debug vengono compilate anche le stampe, mantre quando compilo per il cliente le faccio ignorare al compilatore le cose che non servono. Però così ho printato a schermo un sacco di info per tutto il programma. 

Si possono usare dei `logger` che mi permettono di gestire le stampe (posso inviarle ad altri terminali, decidere di non stampare tutto). 

Altrimenti posso usare degli `assert()` che stoppano l'esecuzione se la condizione è falsa

### Dump di memoria

è un meccanismo orami in disuso. Scrivo su file tutto lo stato della macchina. Quando arrivo ad un certo punto gli dico di salvarli tutta la memoria in un file. Il problema però è che ho solo una lista di 0 e 1. Che però non sono riconoscibili. Era utile qunado si programmava in Assembly.

### Debugging simbolico

gli stati intermedi sono prodotti usando una rappresentazione compatibile con quella del linguaggio usato. Riferendosi ad esempio alle varie aree di memoria con i nomi delle variabili usati nel linguaggio ad alto livello.

Posso fare molte più cose:

I debugger simbolici forniscono ulteriori strumenti (watch o spy monitor) che permettono di visualizzare il comportamento del programma in maniera selettiva (es: inserimento breakpoint, watch su variabili)
 
* gestire la granularita` del passo di esecuzione:
    *  singolo passo
    * entrare dentro a funzione
* Modificare il contenuto di una variabile (o zona di memoria)
* Modificare codice...
    * non sempre possibile... necessita ricompilazione ma poi si prosegue dal punto in cui ci si era interrotti
* Rappresentazioni grafiche dei dati

## Automatizzare il debugging

C'è chi ci lavora: Andrea Zeller ==> lavorava sul delta differential debugging: se ho un programma che con due input molto simili uno fallisce e l'altro no posso fare due esecuzioni e vedere quando le due esecuzioni iniziano a divergere. In questo modo posso trovare dov'è la mia zona critica. Programma: askAigor 

# Vantaggi e svantaggi gruppo test autonomo

### Vantaggi 

quali sono i vantaggi nell'avere un team separato per fare test piuttosto che progettazione?

* Apetti tecnici
    * Maggiore specializzazione
    * Conoscenza delle tecniche e degli strumenti(bisogna rimanere aggiornati)
* Aspetti psicologici
    * Non l'ho fatto io, quindi sono neutrale
    * Indipendenz dalla valutazione

### Svantaggi 

* Apetti tecnici
    * perdita di conoscenze sulla progettazione
    * minore riconoscenza dei requisiti, non conoscenza del programma
* Aspetti psicologici
    * pressione negativa sul team di testing
    * non si sa di chi è colpa

Finisce che spesso il codice che vinee inviato al test è brutto perchè lo inivio velocemente e deve fare ping pong tra i due

### Alternativa

* ruoto i due gruppi ....

# Modelli statistici 

..






***