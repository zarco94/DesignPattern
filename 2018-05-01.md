---
author: Gabriele Zarcone
date: 1 maggio 2018
title: Criteri di Copertura
---
---------------------------------------------

# Testsare i test

solitamente chi scrive il codice e chi invece lo testa sono team diversi. Come faccio a farlo testare per bene?

## Beebugging

Prima di darti i programmi ti aggiungo apposta degli errori. Ti dico che ci sono degli errori e ti do anche il numero. Così chi mi fa il test non mi fa dei test troppo blandi che non mi risolvono gli errori. Finchè non trovo tot errori continuo a fare test. Così creano un test abbastanza approfondito che mi riescono a trovare anche altri errori. Si inizai a criticare tutto il codice se mi si dice che ci sono degli errori. Dovremmmo però aggiungere degli errori con la stessa probabilit di essere trovati come quelli che voglio trovare. Dovrebbero essere di complessità simile e anche con motivazione differente uno dall'altro. Perdo comunque un sacco di tempo, è molto poco efficace. Presuppone troppo lavoro umano. Vogliamo qualcosa di più automatico

## Tecniche mutazionali

faccio delle mutazionio al codice. Invece di mettere tot errori nel programma come facevo nel beebugguing. Invece qui creo un codice nuovo per ogni errore. Riscrivo il codice sempre con UN solo errore diverso per ogni codice. Su tutti i programmi vengono eseguiti gli stessi test, e controllo se il test mi da l'ok anche sui programmi sbagliati. Se mi da l'ok anche su quelli sbagliati allora il test non funziona. Devo verificare che tuti i programmi mutatu vengano distinti dall'originale da **almeno** un caso di test. 

Posso usarlo quando ho già il mio test e vado a valutare se è buono, oppure posso usarlo come trst a sestante. Genero automanìticamnete 100 mutanti e creo un test che li verifichi tutti. 

Non ci interessa qual'è il risultato corretto, ma ci serve qualcosa che identifichi se ci sono delle differenze tra il programma originale e quelli pieno di errori.

### Classi di mutanti

i vari mutanti si distinguono rispetto all'oggetto su cui operano e cambiano a seconda del linguaggio di programmazione in uso, o se è un linguaggio orientato agli oggetti o meno 

* costanti e variabili
* ....
* ....

## Approcci al testing





***