---
author: Gabriele Zarcone
date: 24 marzo 2018
title: Verifica e Convalida
---
---------------------------------------------

Con le condizioni composte otteniamo dei test che esplodono e hanno troppi casi. Se invece rimango stoto la solgia e mantengo 

# Altri criteri di copertura

è più efficace fare un test semplice insieme all'analisi statica piuttosto che un test complesso.

## Gestire i cicli

non abbiamo ancora considerato i cicli e le iterazioni, ma solo 

N copertura dei cicli voglio che il mio test testi N iterazioni di cicli. Non lo faccio sul ciclo infinito ma solo su un numero finito N. Qual'è N? Posso scegliere un N che voglio ma i  cammini possibili crscono esponenzialmente.

N = 2 equivale già a differenziale un if da un ciclo.

Un ciclo eseguito 0 volte vuol dire che (testa la condizioni in cui) le postcondizioni devono essere già valide...

Un ciclo eseguito 1 volta vuol dire che (testa la
condizione in cui) le postcondizioni devono essere valide al verificarsi della condizione di uscita...

Un ciclo eseguito piu’ di 1 volta testa la condizione in cui l’invariante di ciclo piu’ le condizioni di uscita implicano le condizioni di uscita...

Anche l'N copertura posso considerarlo come una copertura fattibile.

fino ad adesso abbiamo creato critri partendo dal grafo di controllo...possiamo partire da come è fatto il codice?

COmplementare al flusso di controllo abbiamo anche dei grafi dhe analizzano il **flusso dei dati**. I dati però sono qualcosa che evolve e quindi dinamici. Devo eseguire per capire i codici. Dovrei fare esecuzione per vedere se fare un esecuzione o meno.

Ma sui dati oposso lavorare anche staticamnte ==> Analisi data flow

#  Analisi Data Flow

non nasce come analisi di test ma per fare ottimizzazione dei compilatori linguaggi di programmazione

le tipologie di operazioni che posso fare sui dati le posso classificare in maniera diversa

* oeprazione di **definizione**: cmabio il valore ad una variabile in maniera deterministica (prevista) (es assegnamento o una read o una funzine che cmabia il valore della variabile)
* operazione di **uso**: sto usando un valore, lo sto vedendo (print, ++i=uso il valore, lo definisco e lo uso di nuovo)
    * predicativo
    * nelle condizioni vero/falso
* operazione di **annullamentoi**: viene cambiato il valore ma non posso fare affidamento su quello che c'è dentro dopo. (es variabile chiamata ma non assegnata in C, o quando una variabile locale esce dalla scope di quella variabile)

per ogni variabile de mio programma posso vedere le sequenze di definizione, usoi e annaullamenti che succedo a quella variabile. In maniera statica

Il compiolatore usa questi data flow per vedere se può ottimizzare duqlcosa (se ho  due definizinoi consecutive per la stessa variabile posso anche togliere la prima)

In ingegneria del software invece se c'è qualcosa di strano vado a vedere se è anche giusto o sbagliato

## Regole Data Flow

non sono errori perchè li posso tradurre ma dal punto di vista ingengneristico sono errori. Infatti alcune cose di queste in Java non si possono fare e in C invece si (sono Warning) .. quindi non sono errori assoluti.

### au

> L’uso di una variabile x deve sempre essere preceduto in ogni sequenza da una definizione senza annullamenti intermedi
>
> ... au ... ERRORE

### dd da

> La definizione di una variabile deve sempre essere seguita da un uso prima di un suo annullamento o definizione
>
> ... dd ... ERRORE  
> ... da ... ERRORE  

Potrebbe anche essere che una dd sia corretta perchè magari la scrittura sia più leggibile


### aa

prima di 

## Sequenza

P(p; a) indica la sequenza ottenuta per la variabile a eseguendo il cammino p

Per rappresnetare P in caso di cammini con cicli o di decisioni uso delle espressioni regolari:

* `|`   ----->    pe rappresentare alternative
* `[]`  ----->    per rappresentare opzionalita (0..1) * per rappresentare cicli (0..n)
* `+`   ----->    per rappresentare cicli (1..n)

## Data flow come criterio di copertura = Criterio delle definizioni

> Un test T soddisfa il criterio di copertura delle definizioni se e solo se per ogni nodo i e ogni variabile x appartenente a def(i) T include un cammino libero da definizioni da i ad almeno uno degli elementi di du(i,x)

ogni definizione viene ricontrallato da uno dei sui possibili usi.

[formula in foto]

## Criterio di copertura degli Usi

> Un test T soddisfa il criterio di copertura degli usi se e solo se per ogni nodo i e ogni variabile x appartenente a def(i) T include un cammino libero da definizioni da i ad ogni elemento di du(i,x)

[formula in foto]

L'unica cosa che cambia è il per ogni al posto dell'esiste. Il per ogni però non mi richiede che ce ne sia almeno un (potrebbe non essercene neanche uno), mentre l'esiste me ne cheiede almeno uno 

devo controllare tutti gli usi con dei test prendendo dei cammini che mi prendano tutti gli usi. Se un cammino non mi passa su tutti gli usi allora mi serve averne un altro che tocca gli usi che non prende quelli non presi prima.

Devo scegliere se prendere dei cammini che mi minimizzano il numero di cammini che mi servono per completare il test, oppure minimizzare il numero di iterazione per ogni singolo caso di test. Devo scegliere quello dei due che mi minimizza il tempo di esecuzione del test. 

Un test mi serve per evidenziare un malfunzionamento e cercare con il debugging l'anomalia. mi è più semplice trovare l'anomalia se ho mmolti csasi di test piccoli che mi partizionano il codice in piccole parti. Così se so che il problema è in quella zona allora poi è più veloce ricontrollare quella singola zona piuttosto che avere un unico caso di test che mi controlla tutto insieme.

# Copertura dei comandi

Definizinoi e usi sono un caso particolare di comandi

Che legame c'è tra usi, definizioni e comandi?

* è possibile coprire i comandi senza le definizioni

* è possibile coprire le definizioni senza coprire i comandi

e lo stesso per gli usi

Non mi richiedono la copertura totale dei comandi.

# Criterio copertura dei cammini 

# Data Flow non solo per le variabili

posso appliccarlo anche ad altri oggetti (es i file: apertura, lettura, scrittura). Ci sono dei vincoli anche per i file che posso controllare: non posso scrivere se prima non apro il file

Posso farlo su un qualsiasi oggetto che io vado a definire

# Copertura del budget

mi fermo quando sono finiti i soldi o quando è finito il tempo (ho mezz'ora di tempo per esempio)

non ho nessuna informazione sull'efficacia del test. Perchè dipende come lo uso il tempo per il test. E in più dato che è fatta per ultima viene spesso sacrificato. Anche questo come cosa positiva del TDD(lo faccio di vola in volta il test, consegno solo ciò che è verificato)

InteliJ: run with coverage. Non mi basta più il verde ma voglio anche la copertura del 100%

# Nell'Object Oriented

Nei linguaggi procedurali il programma e’ composto da funzioni e procedure che si chiamano a vicenda scambiandosi dati tramite i parametri

Nei linguaggi OO, gli oggetti hanno legati metodi, ma anche uno stato. Lo stato è un concetto nuovo di quello che abbiamo definito fino ad adesso.

I metodi non possono essere sempre significativamente testati isolatamente

Cosa è una unità testabile? Dalla procedura ci si sposta alla classe

## Copertura della Classe

possiamo ragionare direttamente sul grafo degli stati, posso:

* coprire tutti i **nodi**: =coprire tutti gli stati del progetto
* coprire tutti gli **archi**: =coprire tutti i metodi per ogni stato
* coprire tutte le coppie di **archi in_/out**: volgio sapere se arrivando da un nodo piuttosto che un altro mi porta un compoirtamento diverso. Considereo come ci sono arrivato in uno stato.

## Testing ed Ereditarietà

Un'altra cosa che caratterizza l'OO è l'ereditarietà. 

Se ho testato già la classe padre della classe figlia dovrò comunque testare anche quello già testato nella classe padre, perchè magari avevo una chiamata alla parte modificata. 

## Classi astratte

non si possono neanche istanziare, come faccio a testarla?

posso però iniziare a capire alcune cose come funzionano se la classe astratta non è solo uno scheletro ma ha del codice dentro. Magari testo solo un metodo già ben definito nella classe astratta.

## Late dynamic binding

i cammini vengono definiti a runtim e non posso farci analisi statica


## Conclusioni

L'oggetto da testare non è più il singolo metodo ma tutta la classe. 

* Isolo la classe usando moduli *stub* per renderla eseguibile
* Implemento metodi astratti con metodi stub
* Aggiungo una funzione che permette di esaminare lo stato dell'oggetto: devo poter guardare lo stato dell'oggetto per capire se il test passa o meno. Devo vedere se lo stato è cambiato.

Non posso stampare lo stato (potrebbe esserci errore nella stampa), devo testare lo stato. Senza però modificare il codice solo per il test. Non bisogna **MAI** modificare il codice con qualcosa che non serve al cliente ma che ti serve solo per testarla. Se l'aggiungo allora il cliente potrebbe usarla e quindi quella funzione la devo mantenere.
Non la posso neanche togliere perchè testerei un programma e ne consegnerei un altro.

## Problema

se non abbiamo il diagramma degli stati?

me lo posso calcolare con della reverse engineering, ma non lo faccio in questo modo con molta inteligenza. Prendo sicuramente molti più stati di quelli che ci sono in realtà. Ripeto semplicemente il codice e non la macchina a stati se guardo solamente il codice.








-------------------------------------------------------------------