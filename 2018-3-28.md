---
author: Gabriele Zarcone
date: 28 marzo 2018
title: Object Orientation
---
---------------------------------------------
(lez 9 - seconda parte)

# Quali classi?

* Entity: i veri e propri oggetti che caratterizzano il dominio applicativo.
* Controllo : gestiscono gli eventi
* Boundary: rappresentano l'interfaccia


Un altro modo per classificare le classi, non proprio dell'informatica:

* concetti
* cose reali
* ruoli e persone
* eventi
* organizzazioni
* posti

sono cose molto diverse tra loro. 

Posso usarle come punto di partenza per scoprire le classi. Ma dovrei richiedere al cliente la cosa. Posso usarlo invece come controlllo. Per vedere se le cose importanti le ho già scritte come classi. Tenendo presente che non deov per forza rappresentare tutte le cose reali. Non mi serve avere l'oggetto della mamma del dipendente, oppure non voglio tutte le info di una bibliotecaria se faccio un sistema per biblioteche. Non mi serve sapere la sua data di nascita ad esempio.

## CRC card

http://c2.com/doc/oopsla89/paper.html

http://www.softstar-inc.com/Download/Intro%20to%20CRC.pdf

più che per identificare le classi è uile per ragionare sulle dipendenze, gli attributi ecc. sulle classi che ho già trovato. Quando poi faccio il gioco, posso trovare delle cose che mi servono in più sulle dipendenze fra le varie classi e capisco cosa le caratterizza. O i metodi che mi aiutano anche a capire come devono interagire le varie classi. 

## Carte

ogni classe ha una carta. Con scritte:

* Responsabilities
* Collaboration

ogni persona prende una carta e si inizia a dialogare. "Io ho bisogno di questo servizio....Io posso darlo.... ecc"

Capisco quali sono le **responsabilità** che ha la mia classe verso le altre classi:  le info che la mia classe si deve memorizzare.

E capisco qualio sono le **collaborazioni** che devo instaurare tra le varie classi e quindi i metodi che devo implementare. 

# Pattern

può aiutare nella fase di modellazione per la decisione delle classi. So già quali classi mi servono per risolvererb il problema.

> Pattern = soluzioni di problemi ricorrenti ripetibili

sono la soluzioni di problemi molto generici che potrebbero capitare a chiunque.

## Anti Pattern

sono le cattive soluzioni ma che sembrano molto ragionevoli. Apparentemente la soluzione sembra essere la migliore ma più si va avanti diventa un'idea pessima, ne rimango invischiato. L'antipattern mi dice: attento che in questa situazione anche se sembra la soluzione più ovvia, guarda che in realtà fa schifo. 

## Idioma

i pattern sono delle soluzioni di come costruisco e modello la mia soluzione ed esula dal linguaggio di programmazione. L'idioma è l'implementazione del pattern per un determinato linguaggio. Viene specificato perchè magari un deteeminato linguaggio ha un costrutto perfetto per quello che altri non hanno, quindi l'idioma mi consiglia che per quel patter in quel linguaggio si può usare un particolare costrutto di quel linguaggio.

## Quali sono i pattern

Pattern devono essere scritti in maniera chiara. Sono stati decisi che i più importanti sono i 23 della Gang of Four. Che furono i primi a sviluppare dei pattern che usavano per risolvere problemi di grafica, ma che erano tanto generali che andavano bene anche per altre cose.

## Meta Pattern   

astraggo i pattern e guardo cosa sono le componenti principali dei pattern 

### Hook Method

metodo astratto che customizza e rende proprio del mio dominio applicativo il pattern. Scrivo un templete con alcuni punti modificabili così che io possa modificarli e metterci cose del mio dominio applicativo per applicare il pattern alle mie esigenze. Hook sono delle parti di codice non ancora scritte ma che il template già richima. Per questo deve essere astratto: uso del codice che non è ancora stato scritto. Chiamo quel codice anche se nessuno lo ha mai scritto. L'unicino è il riferimento a quella cosa e lo uso come se fosse veramente implementato, quando in realtà viene implementato solamente quando applico il pattern al mio dominio applicativo.

Parte calda = la parte di codice che viene modificata per poter applicare il pattern al mio dominio.

### Template Method

il template invece è il codice che usa gli hook e non viene modificato qunaod voglio usare il pattern. E' tutto ciò che non è hook ma che ingloba gli hook. 

Parte fredda = non viene mai modificato quando applico il pattern. 

#### Relazione hook template

* Unification: nella stessa classe ho hook e template
* Separation: ho due classe separate, hook class e template class e nenache relazionate fra loro
* Connection: sono in classi separate ma sono tra loro in relazione.

# Pattern Gang of Four
sono 23 pattern separati in: 

* Creazionali: per costruire oggetti
* Comportamentali: interazioni tra oggetti
* Strutturali: composizione di classi di oggetti


# Observer [COMPORTAMENTALE]

è un pattern molto usato. Fa parte anche di pattern più complessi (devo sempre considerare le relazioni con gli altri pattern). 

Quando ho motle classi che devono reagire al cambiamento di stato di un unica classe. Ho un osservato e molti osservatori. Però con una minima conoscenza gli uni degli altri. Non voglio che l'aggiunta di un osservatore o la modifica di un osservatore mi debba costringere a cambiare enormemente l'osservato. Voglio inolre un legame **dinamico**. non definisco chi osserva chi, ma in fase di esecuzione posso modificar chi osserva chi. 

### Polling

l'osservatore ogni tanto richiede all'osservato informazioni e verifica se ha cambiato o meno il suo stato. Il problema però è che ho una perdita di performance e in più tutti gli osservatori continuerebbero a chiedere all'osservato e l'osservatore impazzisce.

### Interrupt

Faccio il contrario allora. Il soggetto comunica che è cambito qualcosa. Chiede a chi è interessato al suo stato di registrarsi. Che è registrato riceve la notifica che lo stato è cambiato solamente quando cambia lo stato.  

E' comportamentale perche a fronte di un cambiamento di stato mi determina cosa fare.

* Template = **subject**: rifà sempre le stesse cose e avverte gli observer che è cambiato lo stato
* Hook = **update**: è cosa deve succedere quando cambia lo stato. 

Update è l'uncino al quale il subject si può aggangiare per dirgli ora fai quello che ti serve. Il subject richiama l'update ogni volta che cambia lo stato, ma quello che deve fare l'update non è definito e deve essere specificato dall'utente 

Update e Subject sono in due classi **separate** collegate con un aggregazione.  Aggregazione perchè ci deve essere qualcuno che l'osserva se no non sarebbe un osservato. Ce ne deve essere almeno 1. Se tra subjecg e Observer ho 1-1 vuol dire che quando nasce un Observer allora osserva già qualcosa (osserva sempre qualcosa per tutta la vita). Se metto 0-1 invece posso crearlo indipendentemente da un osservato. Se scelgo uno o l'altro cambia il modo in cui faccio il costruttore(se 1-1 passo l'osservato che dovrà osservare per tutta la vita quando lo creo)

NAvigabilità è da interfacci asubject  a interfaccia observer (Subject conosce l'observer mentre l'obeserver non conosce il subject). Quindi se dico che sono collegati dcon cardinalità 1-1 vuol dire che nel costruttore gli passo un subject sul quale lui si registra (ma non si ricorda a quale subject). Fin dalla sua nascita lo registro a quel subject. 

Ho un'aggregazione fra interfacce ma l'interfaccia non può avere attributi. Lo faccio però perchè:

* posso non realizzare l'aggregazione come un attributo
* l'interfaccia è come un contratto con dei metodi da implementare. Così le classi che implementano l'interfaccia dovranno anche implementare questa relazione (lo faccio diventare parte del contratto.)
* con un interfaccia posso creare più tipologie di osservati che comunque sarebbero compatibili con gli osservatori perchè la aggregazione è sull'interfaccia. **dipendo solo dalle cose astratte** (dependecy inversion)

`ConcreteSubject` e `ConcreteObserver` sono le due classi che implementano le interfacce. 

## Scenario d'uso

ho una centralina metereologica con sensori di:

* temperatura
* umidità
* pressione

la centralina esporta un interfaccia software. Ho vari terminali che usando i dati dei tre sensori mi danno info diverse:

* le previsioni del tempo
* storico
* ....

Oppure potrei avere dei telefonini che mi prendono le info con un app. 

Ho quindi un osservato e un numero indefinito di observer. 

## Template

* `registerObserver()`
* `removeObserver()`
* `notifyObserver()`

essendo l aparte fredda non hanno a che fare con la mia implementazione. Saranno sempre uguali per ogni pattern

## Hook

2 modalità per fare `update`:

* modalità **PUSH**: l'osservatore riceve contemporaneamente notifica e aggiornamento. Ti notifico che è cambiato lo stato e te lo passo. Va bene solo se il tempo di trasmissione dello stato è gestibile enon troppo lungo (se sono 5GB anche no)
* modalità **PULL**: ti dico solo che è cambiato lo stato e poi sei tu che ti vieni a prendere solo le info dello stato che ti serve e non tutto lo stato. 

a volte si fa ibrido: ti passo un info che serve sempre e poi tu ti puoi andare a prendere anche altro. Così evito che tutti vengano a chiedere le cose che potrei passarli.

Volgio che il pattern siano generici. Quindi le classi devono essere generiche. Non devono sapere nulla di quelle concrete. Nulla di come è fatto lo stato. 

(Lez 10-1)

In modalità Push devo passargli lo stato. Se sono in modalità Pull invece posso anche non passargli niente ma devo far conoscere all'observer chi sono io -(subject) perchè per come abbiamo fatto l'UML l'observer non conosce il subejct (navigabilità aggregazione). Come argomento dell'update quidni passo me stesso. lui non lo sa a priori ma glielo passo ad ogni update. 

## Si conoscono

Altrimenti potrei fasr conoscere il subject all'observer. Ma non faccio una freccia bidirezionale. Ma la direzione tra observer e subject (altra direzione) viene fatta tra oggetti concreti. Perchè devo conoscere come viene implementato. 

## Perchè un interfaccia?

Noi usimao un iterfaccia invece di una classe astratta perchè le classi hanno delle limitazioni. Per esempio se il mio subject concreto fosse un figlio di un altra classe ancora, non potrei farlo diventare figlio anche della classe astratta, mi serve un interfaccia. è figlio di qualcosa ma implementa anche l'interfaccia (si può fare). 

## Java

In Java esiste già una classe astratta Observable che ha già implementato tutto. E un interfaccia Observer che contiene solo update(). All'esame posso usare uno o l'altro. Basta che faccio il grafico giusto. 

Java implementa entrambi i metodi (push & pull). Nei metofi della classe Observasble ci sono entrambi infatti ==> Quelli senza Observer nell'argomento e quelli che non ce l'hanno. 

## NotifyObserver

è un metodo publico. Chiunque può notificare gli osservatori. Anche se non è cambiato lo stato. Così il controllo dell'aggiornamento può essere esterno, non solo quando cambia lo stato ma quando voglio io. Aggiungo un `setChanged` che setta una variabile booleana che mi dice se è stato modificato o meno lo stato. Posso così controllare se è stato modificato lo stato e può chiamare o meno la notify. Notify è libero ma funziona solo se la variabile booleana è vera. 

.....

# Swing 

libreria grafica di Java che ha degli "ascoltatori" che sono tipo degli osservatori. Ho dei listener e ad un bottone posso associare uno o più ascoltatori che reagiscono all'evento del bottone. 

* Observsble = JButton
* Observer = va implementato (actionPerformed) 

* ActionPerformed = hook
* ActionListener = template