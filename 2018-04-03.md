---
author: Gabriele Zarcone
date: 3 aprile 2018
title: Pattern
---
---------------------------------------------

(Lez 10-1)


# Decorator (wrapper)

permette di aggiungere nuove funzionalità dinamicamente. Per esempio ho il testo e voglio decorarlo cn un bordo o con delle scrollbar. L'oggetto testo è sempre lui, cqmbia come lo visualizzo. Io non sono però sicuro delle decorazioni che voglio aggiungere, devo essere in grado di aggiungerele dopo: non può essere statico ma dinamico. 

Un altro esempio è la pizza: ho la base(pasta) e una serie di topping che posso metterci sopra. Il numero di pizze possibili sono moltissime, con un sacco di combinazioni.

## Specializzazione

Faccio una serie di specializzazioni della base della pizza. Capperi = figlio della margherita. E se devo aggiungerne altri aggiungo una classe. Ogni volta che aggiungo un'ingrediente il numero possibile di pizze che posso fare cresce esponenzialmente. Ogni volta che aggiungo un ingrediente alla mi alista degli ingredienti disponibili inoltre dovrei cambiaren anche tutti i metodi delle altre classi in modo che possano interagire con la classe curcuma. Ho un esplosione di classi.

## Unica classe

Faccio un unica classe che ha delle variabili booleane che contengono se c'è o meno la presenza di un' ingrediente. Così però la classe margherita diventa gigantesca percheè tutti i suoi metodi (es quello che calcola il costo) diventano giganti, perchè devono tenere conto di tutte le possibili combinazioni  e avere un comportamento diverso per ognuna. E' molto negatiovo per L'open close principle => aperto alle evoluzioni ma chiuso alla modifica puntuale di quella già esistenti, cioè se voglio aggiungere nuove funzionalità non dovrei andare a modificare quelle preesistenti. Se voglio aggiungere un ingredinete qui invece devo andare a cambiare tutti i metodi della classe. 

## Pattern decorator

distingue il concetto di **decoratore** e oggetto **decorabile**.

* decoratore = aggiunge una caratteristica al decorato, ma in più deve poter essere decorato anche a sua volta. 

prima ragionavo con delle istanze. 

Concrete Component:
ho una serie di metodi che vengono resi comuni per tutti i componenti. 

Decorator capace di decorare un concrete component, perè un decorator non aggrega un concrete componetne perchè altrimenti per ogni base di pizza dovrei avere una aggregazione specifica. Quindi ho una astrazione con un interfaccia Component. Così qualunque sia la base della pizza la cito in un unico modo. Ma non è l'unico vantaggio, perchè Componette può essere implementato non solo dai Concret4Compontent ma nache da un Decorator. In questo modo posso Decorare anche un Decorator. Ho una Recursive Connection (meta-pattern). Decorator può essere un componente e quindi può decorare un decorator. 

## Cardinalità

un decorator decora un solo componente. Un componente non è decorato da più decorator perchè non è collegato a più decorazioni, ma a solo ad una che a sua volta e collegata ad un altra e così via, in questo modo ottengo più decorazioni. Quindi non 1-N, Ma nenache 1-1 perchè un oggetto componente non è sempre decorato da qualcuno, non mi potrei fermare, invece esistono dei componenti che non vengono  decorati da nulla. Quindi ho 1-0,1 (o 0 o 1). 

#### Errore su slides:

Decorator ha un aggregazione con l'interfaccia component, ma se è indicata nell'UML come aggregazione non devo metterci un attributo (o metto la freccia o metto l'attributo). Se metto l'ìattributo mi obbliga a farlo con l'attributo, con la freccia posso farlo come voglio. 



