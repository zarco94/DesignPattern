---
author: Gabriele Zarcone
date: 27 marzo 2018
title: Object Orientation
---
---------------------------------------------

(lez 8-1parte, lez 9-2parte)

# Concetti dell'Object Orientation

l'OO non è un linguaggio ma un modo di pensare e di interfacciarsi ai metodi risolutivi

Si può progammare ad oggetti anche in C o assembly. Ovvio che se il linguaggio ha gli stessi costrutti e astrazioni dell'OO è più facile, ma non è impossibile con altri linguaggi

Per capire il problema lo penso OO e poi però posso implementarlo come voglio, anche in C

OO non risolve il problema, mi da un modo per risolverlo, degli strumenti

Ha pochissimi concetti, anche banali

* classi e ereditarietà
* polimeorfismo
* collegamento dinamico

non sempre sono facili da usare però, e spesso si fanno dei grandi errori. Soprattrurro perchè sono concetti sempllici. 

Per esempio finisce che ho 50 classi quando me ne servono solo 4

E' uno dei metodi per risolvere ma non è l'unico e non sempre è il migliore (progr. funzionale, aspect orientation)

# Programmazione Modulare
è il padre della OO e studia come costruire un sistema in moduli

es: MODULO A2

la programmazione modulare ha una serie di ragionamenti su quello che deve fare un programma che è stato ereditato pari pari dall'OO. OO aggiunge cose nuove ma moltissime le prende dalla progr modulare

## Principi Programmazione Modulare
* **astrazione**: creare una scatola e darle un nome senza 

* **encapsulation e information hiding**: posso anche renderla opaca la scatola e posso usarla senza guardarci dentro

* **encapsulation**: chiudo a chiave la scatola e non posso usare quello che c'è dentro

* **tipi di modulo**: ci sono diversi tipi di moduli con diverse funzioni

## Relazioni fra moduli

matematicamente: dato l'insieme S di moduli allora una relazione è un sottoinsieme di SxS

cioè un insime di coppie ordinate

sono rappresentabili graficamente come un **grafo orientato**

### Tipi di relazione

* **usa**: il modulo A ha bisogno di quello che ha il modulo B -> A usa B. Vuol dire che A ha bisogno di una qualsisi cosa contenuta in B

* **is_component_of**: B è composto da a1 a2 a3, vuol dire che se li metto insieme ottengo B. Mettendo insieme delle classi ottengo una generalizzaine più ambia a cui posso dare un nome

Le relazioni sono rappresentabili graficamente con un grafo orientato. Attenzione alle relazioni cicliche. Non so più da dove partire perchè uno dipende dall'altro. Non posso più isolare un punto e partire da quello

## Astrazione e encapsulation 

## Tipi di Moduli
storicamnete si sono create diverse tipologie di moduli

* **PROCEDURALE** singole procedure senza dati

* **DATI** sono solo dati: tabella che salva uno stato

* **ABSTARCT OBJECT** ho solo l'oggetto astratto che mette insieme procedure e dati. E' solo l'istanza, esiste solo quell'oggetto. Mi fornisce dei dati più delle funzioni che mi servono per lavorare su quei dati e posso interagirsci con la stesso livello d'astrazione dell'oggetto

* **ABSTRACT DATA TYPE**  potrei voler più oggetti tutti uguali tra di loro. Mi serve un progetto di come è fatto un oggetto (classe) da cui posso genereare tutte le istanze uguali che voglio. Definisco un template di come devonon essere le mie istanze. Java ad esempio ha solo questo, non posso creare una istanza senza la classe

* **GENERICI** sono definizioni parziali di un qualcosa perchè parametriche rispetto ad un altro tipo di cui ti devo ancora parlare (interfacce). Devo stare attento qunado li uso ma sono molto utitli pe rsemplificare la compilazione e riduce gli errori. 

# Object Orientation
si basa sui Abstract data type che chiama **CLASSI** 

definisce nuove realazioni:

* **GENERALIZZAZIONI**  *(ereditarietà)* 
    * l'ereditarietà però e una cosa del linguaggio, è un modo per supportare la generaalizzazione, ma non è l'unico, posso creare una generalizzazione anche senza usare il meccanismo dalla ereditarietà

* **AGGREGAZIONE** 
    * equivale a is_part_of non è composto ma è una parte, non lo completa tutto

nuovi concetti (non possono esserci senza avere generalizzazione e senza il polimorfismo non posso avere il collegamento dinamico):

* **POLIMORFISMO**

* **COLLEGAMENTO DINAMICO** (dynamic binding)

non sono legati uno all'altro, può esserci polimorfismo anche senza coll din e viceversa

## CLassi
permettono di definire un insieme di oggitti che condividono:

* Comportamenti (*metodi*)
* Conoscenze (*attributi*)

sono il progetto di costruzione di un oggetto

possono anche essere incomplete (*classe astratta*)

permettono di saparae la definizione dell'intefaccia e della definizione vera e propria. Separano ciò che interagisce con l'esterno e nascondono in funzionamento (information hding)

# UML
è un linguaggio di *progettazione* 

è l'unione di tre diverse idee di 3 informatici 
i tre linguaggi però non erano completamente compatibili e spesso non si sono messi d'accordo su alcune cose. Quindi le hanno prese tutte e tre e fanno scegliere all'utente. 

La prima versione era un gauzzabuglio di molti concetti presi da  concetti differenti che si uniscono tutti insieme. 

in UML 2.0 si è iniziato a formalizzare i costrutti

## Metamodello
posso definire 4 livelli 

livello più basso: quello più vcino a noi =oggetti in esecuzione
livelllo 2: progettazione
livello 1: come sono fatti i costrutti sottostanti
livello 0: c'è solo la classe che generalizza tutto il resto

ad ogni liello ho una astrazione maggiore rispetto al livello precedente. é un meta meta meta.. linguaggio

## Diagrammi UML
sono le foglie dell'albero in figura

ci sono 3 che non si possono non sapeere bene:

* diagramma delle classi
* degli stati
* di sequenza

gli altri sono comunque importanti ma questi sono i **fondamentali**.

## Diagrama delle classsi

una classe è un rettangolo diviso in 3 zone

* nome classe
* attributi
* metodi

ci sono alcuni simboli per indicare i gradi di protezione:

* `+` publico
* `-` privato
* `~` package
* `#` protected

# GENERALIZZAZIONE

è una relazione tra classi

ci permette di definire una classe come una specializzazione di un altra classe. Non riparto a definirla da zero

E' la stessa classe con in più altre cose: è un write once. Permette quindi il riuso del codice: posso definire più classi da quella padre.

ereditas tutto quello che ha la classe padre

Una classe aggiunge attrributi e metodi dalla classe padre

Può anche cambiare come svoglge un compito ereditato dalla classe padre

non dovrebbe mai però eliminare degli attributi o dei metodi 

Può essere singola o multipla

* ho 1 padre
* ho N padri

Java supporta solo l'eredità singola. 
L'eredità multipla però è comoda -> permette implementaerd più di un interfaccia per la stessa classe.

## IN UML 

> è una freccia a linea continua con punta piena bianca


classe dove c'è la punta della freccia è il padre, l'altro è il figlio da cui eredita tutto. Il padre è una generalizzazione del figlio. Il figlio eredita dal padre. 

### Overriding

lo indico riscrivendo il nome della classe nella sottoclasse, se non lo riscrivo vuol dire che anche la sottoclasse ce l'ha perche lo eredita ma non lo ha ridefinito in maniera diversa.
anche 
Non posso ridefinire delgili attributi, l'unica cosa che posso fare eè cambiare il tipo dell'attributo. Se lo faccio cambia proprio l'attributo

### Classi Astratte

Metodo in *corsivo*: è un metodo ASTRATTO, cioè qualcosa che è definito ma non ancora implementato

se c'è almeno un metodo astratto in una classe allora non è completa. Quindi anche lei è astratta. Anche il suo nome va in corsivo

Posso avevre classi astratte che non abbiano metodi astratti. Può sembrare completa ma magari io la voglio indicare come astratta e non completa.

## Protezione

### Protected

le classi che ereditano da un altra classe sono privilegiate. Possono avere un accesso diverso da quello di tutto il mondo rispetto alla classe padre.

E' il livello di protezione `protected` (`#`)

### Package

solo le classi dello stesso package possono vedere i segreti
è quello di default (quando non scrivo nulla).

in UML: `~`

## Formattazione UML

### Corsivo

* per le classi e i metodi **astratti**

### Sottolineato

* per gli attributi e metodi **statici**. 

VUol dire a livello di classe e non solo di istanza. 

Un **attributo statico** C'è ne è uno solo per tutti gli oggetti di quella classe. Esiste già prima della creazione dell'istanza

Un **metodo statico** è un metodo che può essere invocato partendo dal nome della classe, anche senza l'esistenza di una istanza. Di conseguenza può essere usato solo con attributi statici. 

# POLIMORFISMO

permette di usare un oggetto A (appartente alla classe CA) ovunque possa essere usato un oggetto appartenente alla classe da cui CA eredita

Se CA eredita da CB allora istanze della classe CA possono essere usate dove possono esserci istanze di CB 

i figli possono presentarsi al posto dei padri ma non viceversa

non è solo riuso del codice

è come se eredita_da == è un sottotipo_di 

la classe che eredita è un sottotipo del padre (animali -> gatto)

# COLLEGAMENTO DINAMICO

è possibile fare overriding quindi vorrei che l'implementazione del metodo eseguita fosse quella ridefinita nel figlio se ho un istanza del figlio

Se al posto del padre trovo un figlio e chiamo un metodo del padre ridefinito dal figlio vorrei che venga richiamata l'implementazione nuova del figlio

Devo  aspettare il  runtime -> è dinamico (non statico)

Chiama l'implementazione più vicina alla classe realmente presente lì

Permette di chiamare del codice che non è ancora stato scritto. E' molto flessibile è mantenibile infatti

# Come uso i concetti dell'OO

## Principio di sostituzione di Liskov

prima regola dell'OO è quella di non cancellare i metodi. I figli devono saper fare tutto quello che sa fare il padre, niente di meno; poi possono fare anche cose in più.  Non posso togliere conoscenze.


> Sia q(x) una proprietà provabile da oggetti di tipo T. Allora q(y) deve essere vero per oggetti di tipo y di tipo S se S è sottotipo di S.

i sottotipi devono soddisfare tutte le proprietà che rispettano i padri, altrimenti non sono sottotipi. Se non fosse così non potrei fare collegamneto dinamico: non potrei mettere il figlio al poisto del padre

## Design by contract

Meier ragione su pre e post condizini di un metodo. Faccio un contratto con il metodo. Se tu mi invochi allora mi prometti che ci sono delle determinate precondizioni, s ele precondizioni sono vere il metodo mi assicura che fa tutto quello che promette. Se non sono vere le precondizione allora il metodo può fare ciò che vuole.

Se il metodo lo eredito da una classe figlia e lo ridefinisco allora la mia ridefinizione deve funzionare ancora quando funzionava l aprecedente definizione:

* precondizioni devono essere uguali o più ampie

le post condizioni devono fare la stessa cosa di prima o più precisa 

* postcondizione uguali o più strette

Eifel (linguaggio di Meier) controllava con la sintassi se veniva rispettata questa cosa e quindi se rispetta il principio della Liskov.

# Associazioni

LA seconda delle relazioni che vediamo; ci sono diverse relazioni (generalizzazione, associazioni...)

è una relazione tra istanze di classi, non tra classi -> != generalizzazione

un istanza deve riconoscere e ricordare un altra istanza. Studenti sono in relazione con bellettini, non con tutto il genere dei professore. Siamo associati con un istanza e non con una clsse

Implica una relazione usa. Devo tenere traccia di un altra istanza perchè devo usare le sue funzioni

Quando due oggetti interagiscono vuol dire che c'è una relazione

Un associazione è la più smeplice tra tutte
**In UML:**

> la indico come una linea semplice, con:
>
>> **label**: nome della relazione (Es: segue_corso_di)
>
>> **ruolo**: è utile quando sono associazioni tra due classi uguali. Lo useremo per dare dei nomi agli attributi
>
>> **moltiplicità**: indica quante istanze di una sono in relazione con con quante istanze dell'altra e viceversa. La molteplicità lontana alla classe si riferisce a quella classe lontana.

## Navigabilità associazioni

delle associazioni non sempre sono a doppio senso. Spesso una istanza deve conoscere l'istanza dell'altra ma può non essere necessario il viceversa. 

ES:_ il professore non sa le istanze singole dei suoi studenti.

Qundo progetto devo decidere quali istanze devo memorizzare

> la linea senza nulla è una associazione bidirezionale

> se ho una freccia non piena (->) invece le istanze sono in associazione ma quella che punta deve conoscere e ricordare quella puntata, ma quella puntata non deve ricordare chi la punta anche se è in relazione con lei.

## Associazioni e attributi

spesso l'associazione si fa attraverso la definizione di un attributo, ma non è l'unico modo. 

Non mi costringe ad usare un attributo. Posso anche farlo in maniera diversa. 

**VICEVERSA** non è vero che ogni volta che ho un attributo in cui ho un associazione

Con gli attributi posso fare anche aggregazione e composizione che sono casi particolari di associazioni.

Non è perforza necessario separare associzione da aagregazione, composizione ecc.. potrei all'inizio mettere solo associazioni e poi in secondo luogo precisare che tipo di associazione.


### Errore

non va segnato in UML sia l'attributo che l'associazione perchè sto ripetendo due volte la stessa cosa. Se metto solo l'attributo o solo l'associazione ottengo lo stesso effetto. Se metto solo la freccia della associazione posso fare quello che voglio per realizzarla, se metto solo l'attributo obbligo a creare un associazione con un attributo.

### [Prossima Lezione. >](./2018-7-28.pdf) 








-------------------------------------------------------------------