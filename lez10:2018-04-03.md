---
author: Gabriele Zarcone
date: 3 aprile 2018
title: Pattern
---
---------------------------------------------

(Lez 10-1)


# Decorator (wrapper)

permette di aggiungere nuove funzionalità **dinamicamente**. Per esempio ho il testo e voglio decorarlo cn un bordo o con delle scrollbar. L'oggetto testo è sempre lui, cqmbia come lo visualizzo. Io non sono però sicuro delle decorazioni che voglio aggiungere, devo essere in grado di aggiungerele dopo: non può essere statico ma dinamico. 

Un altro esempio è la pizza: ho la base(pasta) e una serie di topping che posso metterci sopra. Il numero di pizze possibili sono moltissime, con un sacco di combinazioni.

Si può ottenre in più modi:

## Specializzazione

Faccio una serie di specializzazioni della base della pizza. Capperi = figlio della margherita. E se devo aggiungerne altri aggiungo una classe. Ogni volta che aggiungo un'ingrediente il numero possibile di pizze che posso fare cresce esponenzialmente. Ogni volta che aggiungo un ingrediente alla mi alista degli ingredienti disponibili inoltre dovrei cambiaren anche tutti i metodi delle altre classi in modo che possano interagire con la classe curcuma. Ho un esplosione di classi. 

## Unica classe

Faccio l'opposto: un unica classe che ha delle variabili booleane che contengono se c'è o meno la presenza di un' ingrediente. Così però la classe margherita diventa gigantesca percheè tutti i suoi metodi (es quello che calcola il costo) diventano giganti, perchè devono tenere conto di tutte le possibili combinazioni  e avere un comportamento diverso per ognuna. E' molto negatiovo per L'open close principle => aperto alle evoluzioni ma chiuso alla modifica puntuale di quella già esistenti, cioè se voglio aggiungere nuove funzionalità non dovrei andare a modificare quelle preesistenti. Se voglio aggiungere un ingredinete qui invece devo andare a cambiare tutti i metodi della classe. va contro l'open close principle

## Pattern decorator

= il modo giusto per farlo

distingue il concetto di **decoratore** e oggetto **decorabile**.

* decoratore = aggiunge una caratteristica al decorato, ma in più deve poter essere decorato anche a sua volta. 

prima ragionavo con delle istanze della specifica istanza, ora invece ho tranti oggetti decoratori e decorati.  

### Concrete Component:
ho una serie di metodi che vengono resi comuni per tutti i componenti. 

### Decorator:

 capace di decorare un concrete component, perè un decorator non aggrega un concrete componetne perchè altrimenti per ogni base di pizza dovrei avere una aggregazione specifica. Quindi ho una astrazione con un interfaccia **Component**. Così qualunque sia la base della pizza la cito in un unico modo. Ma non è l'unico vantaggio, perchè Componette può essere implementato non solo dai Concret4Compontent ma nache da un Decorator. In questo modo posso Decorare anche un Decorator. Ho una Recursive Connection (meta-pattern). Decorator aggrega un xomponente e può essere un componente e quindi può decorare un decorator. 

## Cardinalità

un decorator decora un solo componente. Un componente non è decorato da più decorator perchè non è collegato a più decorazioni, ma a solo ad una che a sua volta e collegata ad un altra e così via, in questo modo ottengo più decorazioni. Quindi non 1-N, Ma nenache 1-1 perchè un oggetto componente non è sempre decorato da qualcuno, non mi potrei fermare, invece esistono dei componenti che non vengono  decorati da nulla. Quindi ho 1-0,1 (= o 0 o 1). 

#### Errore su slides:

Decorator ha un aggregazione con l'interfaccia component, ma se è indicata nell'UML come aggregazione non devo metterci un attributo (o metto la freccia o metto l'attributo). Se metto l'ìattributo mi obbliga a farlo con l'attributo, con la freccia posso farlo come voglio. 

## Esempio Caffè  
questo `foto`sono tre componenti che aggregano uno l'altro

`whip` detto visione a cipolla  
parla del caffè: 

* chiamo la funzione `calcolaCosto()` di un caffè scuro con panna

la panna, il cacao sono tutte decorazioni del caffè 

quindi chiamo `calcolaCosto()` su panna che chiama `calcolaCosto()` sulla sua decorazione (cioccolato) che chiama `calcolaCosto()` su caffè. Quando arrivo a uno senza decoratore vengono calcolati tutti i costi partendo dal più interno.


### Implementazioni
due metodi uno calcola il costo e l'altro la descrizione
#### Metodo Statico (con attributo)

> costruisco le cose che mi servono attraverso i costruttori. Salvo le informazioni dell'ogeto decorato negli attributi dell'oggetto decoratore. Non devo andare a chiedere le cose al decorato, sono già salvate nel decoratore  come attributo

```java
abstract class Bevereage{
    int cost();
}

abstract class AbstractCondiment extends Beverage{
    private Beverage beverage;

    AbstractCondiment(Beverage b){
        beverage=b;
    }

    int cost(){
        return beverage.cost() + condimentCost();
    }
    abstract int condimentCost();
}

class ConcreteCondiment extends AbstractCondiment{
    int condimentCost(){
        return 20;
    }
}
```

ogni classe finale ha molto poco da dire, il resto viene astratto nella classe astratta. 

* ho una classe asratta Beverage che ha un `getDescription` già impementato (poteva anche essere una interfaccia)

* Espresso estende Beverageho un prezzo base per le diverse tipologie di caffè

* classe astratta `condimentDecorator()` che non fa nulla

#### Dinamico (con metodi)

> le informazioni relative al decorato vengono richieste dal decoratore attraverso dei metodi del decorato. 

mai usare un `double` per i soldi, non ritornano le somme altrimenti

il decorator viene usato  in moltre classi java.  
Ognuno aggunge un comportamento diverso su come si deve comportare un certo metodo 

## Osservazioni

Se devo aggiungere un nuovo decoratore aggiungo una classe sola e non devo modificasre tutte le altre classi.   

il debugging sarà più complicato perchè continuo ad entrare in oggetti diversi,  ma i vari oggetti sono più snelli ed è più difficile che ci siano errori. 

Questo pattern è perfetto per l'open close principle: 

* chiuso alle modifiche
* aperto alle estensioni

Viene usato in `InputStream`: decoro un flusso d'ingresso con delle caratteristiche. Come è fatto l'input o come sono fatti gli ingressi. Ho degli oggetti base di inputstream che però hanno delle caratteristiche da aggiungerci (lowerCase, buffered ecc.....)

L'ereditarietà non sempre è la soluzione migliore per relazionare due classi. La composizione è molto potente e posso usarla al suo posto. Per composizione si intende usare classi compontenti relative ad un interfaccia

Un esempio di suo utilizzo è la Duck Saga descritta dal libro

## La saga delle anatre

quando uso l'ereditarietà o il controllo su chi eredito. Posso decidere da chi eredito, sono io che lo decido. Il padre però non ha alcun potere sul figlio, non può decidere chi lo può estendere. Chiunque può scrivere una classe che estende la mia classe. Non posso decidere che non mi può estendere.  Posso mettere `final` per non essere esteso da nessuno, ma se permetto a qualcuno di estendermi lo sto permettendo a tutti. (attenzione quindi ad usare l'attributo protected)

Mentre con la composizione ho il controllo, l'interfaccia controlla i metodi che deve avere chi lo implementa. Con l'interfaccia ho il controllo sul figlio. 

la duck saga serve per fare un simulatore delle anatre:

- classe base = DUCK che mi dice che un anatra può nuotare, fare quack o posso ottenere info su di lei 

- poi ci sono delle specializzazioni = specificano il 
colore diverso delle diverse anatre  

voglio aggiungere il metodo `fly` pechè le anatre sanno anche volare. Dovrei aggiungere un metodo alla classe Duck.
è pericoloso perwò modificare la classe Duck, perchè non ho controloo su chi eredita da me, chiunque può ereditare da me (non so chi lo fa). 

magari un altro sviluppatore aveva fatto anche la *papaerella di gomma* che ereditava da Duck, se modifico la classe padre duck anche le paperelle di gomma iniziano a volare. Perchè ho sfruttato l'ereditarietà. 

Quindi è pericoloso cambiare una classe da cui altri classi ereditano.

Possibili soluzioni:

- **override**:     tolgo il metodo fly svuotandolo nella papaerella di gomma -> violo il principio di LIskov -> **NON VA BENE**

- **realizzo con interfacce**:creo un'interfaccia con il metodo `fly` e solo le anatre che volano lo implementano. Così però devo implementare il metodo fly in tutte le classi che implemetnano l'interfaccia, perchè l'interfaccia non implementa nulla. 

- **delega**(strategy pattern): rimappo usando uno strategy pateern. 


## Design principles:

* Quando si progetta devi stare attento a quali sono gli aspetti e le parti che stanno cambiando e tenerle d'occhio in maniera conscia. Devo accorgermi di quali sono i punti di dinamicità. Se continuo a cambiare una parte di comportamneto del mio codice, allora forse è meglio estrarre quella parte con il refactoring. Bisogna separare le parti che continuano a variare.
*  Dependency inversion: programma verso interfacce e non implementazioni (es duck saga)

Se ho dei modi di fare quack e dei modi di volare, vuol dire che esistono dei comportamenti astratti con le loro implementazioni. Ma allora non li dovrà implementare duck, li dovrà contenere. Duck ha un attributo flyBehavior, QuackBehavior che puntano ad uno specifico oggetto che implementa quel behavior. QuackBehavior è un oggetto del tipo quackbehavior che spiega come si comporta su quella cosa.  Delego qualcun altro a fare quella cosa. Ovvero quello che fa lo strategy pattern. 

# Strategy Pattern

Fa uno scheletro di un qualcosa di cui però una parte non sa come deeve esserre fatta, e allora quella parte la delega  aqualcun altro.  Per esempio se devo faretazione  un qualcosa che ordina degli oggetti posso farlo con diversi algoritmi di ordniamenti. QQUindi io creo la struttura e poi la scelta e l'implementazione dell'algoritmo viene delegata. E soprattutto rende intercambiabili le possibilità. 

- tengo in una classe l'aspetto caldo e tutte le parti fredde in una classe separata

- lavora veros astrazioni e non cose concrete

la gang of four lo presenta coe una maniera per definire una serie di algoritmi differenti tra di loro, incapsularli e renderli intercambiabili fra di loro

**es**: andare a capo di word

**es** in JSWING per esempio è il *Jcomponent*: i componenti possono essere inquadrati in diversi tipi di bordo. E' diverso da usare il decorator. Io so già il concetto di bordo, non è più una decorazione qualunque, so cosa voglio è un bordo, non qualcosa che nel tempo potrebbe essere altro. Quindi non mi serve usare decorator. Ma ho comunque tanti tipi di bordo, quindi diverse strategie. E' più statico di decorator. 



