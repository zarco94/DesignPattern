---
author: Gabriele Zarcone
date: 10 aprile 2018
title: Patterns
---
---------------------------------------------

# Singleton

è spesso considerato come una cosa negativo, ci sono addirittura dei tool che ti aiutano a riconoscerlo per sostituirlo. Perchè lo si usava come si usano delle variabiloi globali che è una cosa negativa, perchè non sai più chi li sta toccando quei dati e se qualcosa non funziona devi andare a riguardarti tutto

## Oggetto

un oggetto ha:

* uno Stato
* un Comportamento

C'è anche però un concetto di **identità**:

Due oggetti dovrebbero essere entità distinte anche se tutti i loro campi  hanno valori identici

## in java

JAva non ci dà un oggetto di questo tipo, ci da delle copie di un oggetto, e noi non vogliamo. Ce ne deve essere solo uno. 

Questa cosa la facciamo con il  Singleton

Quindi se voglio che ci sia solo uno oggeto di quel tipo => rendo il **COSTRUTTORE** `privato`

L'oggeto viene quindi creato da oggetti della classe stessa, però per farlo dovrebbe già esserci un oggetto di quel tipo (circo.o vizioso)

## getInstance()
Quindi sarà un **metodo statico** a farlo perchè posso usarlo anche senza aver creato un oggetto di quel tipo

Alla prima invocazione mifa una new, alle successive no ==> crea un oggetto solo

è un metodo statico che restituisce un tipo Singleton

## Codice

```java
public class Singleton{
    protected Singleton(){}
    private static Singleton instance = null;

    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```

è però un codice sbagliato se siamo in ambiente concorrente. Se ho due thread che vogliono concorrentamnte accedere al metodo `getInstance()` è possibile che il primo processo venga interrotto subito dopo aver controllato se instance è `null`, quindi non fa il `new`. Se il secondo processo va in esecuzione e controlla `intance==null` lo trova falso e fa lui la `new`. Quando il primo ritorna in esecuzione ha già controllato l'if e fa anche lui la `new`. E assengna nella stessa variabile l'oggetto che aveva già assegnato all'altro processo.

```java
public class Singleton {
      protected Singleton() {}
      private static Singleton instance = null;
      public synchronized static Singleton getInstance(){
         if (instance == null) {
            instance = new Singleton();
         }
         return instance;
      }
}

```

Aggiungo un `syncronized`.........

Diventa però una soluzione molto inefficente se il `getInstance` viene chiamato tante volte.

## Pattern Double Check

``` java
 public class Singleton {
      protected Singleton() {}
      private static Singleton instance = null;
      public static Singleton getInstance(){
         if (instance == null) {
           synchronized(Singleton.class) {
              if (instance == null)
                instance = new Singleton();
           }
}
         return instance;
      }
}
```
.......

per tutte le volte che 

nel caso in cui l'oggetto esiste di già: sono tornato alla efficenza iniziale perchè non entra neanche nel metodo

s einvece non esiste di già: ..........

idea del double check: una volta che mi chiedo se posso entrare poi me lo richiedo (?)

........

ho comunque un problema perchè un processo che entra e mi fa cambiare l'istance a null potrebbe però essere stoppato prima di inizializzare il Singleton ==> lavorerebbe su un oggetto che non esiste.

Bisogna pensare che potrebbe essere interrotta in qualunque punto, anche a metà di istruzioni complesse.

il double check è comunque la soluzione più accettata di tutte 

# Idioma Singleton Java

si può fare usando gli **ENUMERATIVI**

PERCHè IN JAVA un enumerativo è una classe con un costruttore privato che viene instanziato solo la prima volta. 

```java
public enum MySingleton {
          INSTANCE;
          public sampleOp() {...}
      }
      MySingleton.INSTANCE.sampleOp();
```

Quando viene creato `ISTANCE` chiama il costruttore privato e crea quella sua unica istanza! 

E funziona anche in *ambiente concorrente*

## Classe completamente Statica

Un altro metodo ancora pe farlo è creare tutto statico, non faccio nenache il costruttore. Dato che un singolo oggetto non ho bisogno di costruttore. Così però ho una classe che fa finta di essere un oggetto, non ho tutti i benefici di ereditarietà, polimorfismo e collegamneto dinamico. *Non posso specializzare il mio oggetto Singleton* ==> non posso farne sottoclassi.

### Osservazioni

* è meno flessibile

* non posso ereditare dalla classe singleton e sfruttare collegamento dinamico

* non posso fissae un numero di istanze: basta cambiare `getInstance()` in modo che si blocchi dopo 5 creazioni e non dopo una. Se ho `getInstance()` posso implementarlo con tutta la logica che voglio. [questo è uno svantaggio anche dell'implementazione con *enumerativi*]

# Composite {strutturale}

/////IMMAGINE

è simile come architettura al decorator, ma il suo scopo e utilizzo è diverso

è simile perchè ho delle classi concrete, una astratta e c'è un doppio legame: la classe astratta aggrega e implementa la stessa cosa (come il decorator).

Dal decorator cambia la cardinalità.

> Metto insieme un gruppo di oggetti e voglio che tutti questi oggetti siano visti come un oggetto unico ==> serve per **raggruppare oggetti**

Come su photoshop quando raggruppo più linee e cambio a tutti lo spessore

Utile se voglio cambiare la stessa cosa su tanti oggetti. Non voglio  selezionare ogni volta tutti gli oggetti per cambiare la stessa cosa.

In più posso raggruppare anche dei gruppi, per questo c'è il doppio legame.

## Parti e gruppo

Gestisce delle strutture ad albero per rappresentare gerarchie di parti e insiemi uniformemente, senza accorgermi che ci sia differenza tra foglia e nodo. Posso chiamare un metodo indifferentemente che sia su una foglia o su un nodo.  (?) Senza accorgermi se è una parte o un gruppo

Ci sono dei metodi però che hanno senso solo per il gruppo però e non pe rla parte => ho un problema se non voglio che il programmatore se ne accorga.

### Soluzione

ho più soluzioni:

1. se su una parte chiamo un metodo che può essere fatto da un gruppo allora chiamano un ecezione e poi io gestisco l'eccezione. Non violo Liskov perchè già nell'interfaccia non sapevo farlo, poi l'oggetto figlio richiama un eccezione che comunque fa qualcosa in più.

2. metto tutti i metodi dei gruppi solo nel gruppo ...... ??

3. metto un metodo `getComposite` nell'interfaccia che ritorna un composito(gruppo). in modo da controllare se sono in un gruppo o in una parte. Implemnto `getComposite` sia nelle parti che nei gruppi    
    * nei gruppi ho `return this`
    * nelle parti ho un `return null`

## Osservazioni sul Composite

* Il cliente interagisce esclusivamente tramite l’interfaccia Component

    * Risulta semplice perché non si deve preoccupare se sta interagendo con elemento singolo o composito

* Minore possibilità di controllo su che tipo di oggetti possono essere dentro a particolari Composite

(?) posso scegliere di mettere funzioni gestione....

# State

> permette di modellare cambiamentti di comportametno al cambiare dello stato dell'oggetto

il modo più sbagliato per implmentare quata cosa è lo `switch. viene fuori una classe lunghissima e tutti i metodi devono implementare tutti i casi dello switch. E quando implementi una cosa nuova devi cambiare tutti i metodi e gli switch.

/////IMMAGINE

Ho un Controller con i suoi metodi che è la mia classe principale

I metodi che devono cambiare al cambiamento dello stato della classe li porto fuori dalla classe in una classe *Tool*, così che se devo cambiarli non devo cambiare la classe stessa.

Metto un *aggrgazione* tra le due classi

Il Tool non sa a chi è collegato ma ogni volta che chiamo uno dei suoi metodi gli devo dire chi è il controller. Allegerisco la classe appesantendo la comunicazione.

Tutti i case dello switch di prima diventano diversi metodi di una unica classe Tool. i diversi tool poi saranno delle sottoclassi della intrerfaccia tool e ogni tool diverso implemmnta la sua reazione ad un dato stato che è cambiato.

Se voglio aggiungere un nouovo toool devo solo aggiungere una nuova sottoclasse. Non devo modificare le esistenti ma solo aggiungere roba ==> Open Close Principle

## Automa  a stati finiti

nel senso: sono in questo stato allora succede questo.

(?) E' come un automa a stati finiti. Ci sono delle transizioni di stato da tenere in conto. 

*  a volte è lo stato che .......

devo avere una minima conoscenza degli altri perchè devo poter cambiare lo stato anche degli altri (?)

## State in Together

(?)

```java 
```

## Partecipanti

### Context
è l'unica parte che ha che fare con il cliente

* quello che ha a che fare con lo stato lo rimappa a qualcos'altro
* mantiene un'istanza della classe state

### State

(?)

### ContextStsate

(?)

## Osservazioni 

* Viene partizionato il comportamento nelle varie classi stato

* Viene reso esplicito (e atomico) il passaggio di stato

* Gli oggetti stato possono essere in alcuni casi condivisi (vd. Pattern flyweight)

## Gun Ball Machine

* Parto da `noQuarter` stato in cui nn c'è la monetina dal quarto di dollaro

* posso o riprendemi la moneta o girare la manopola

* se la giro posso ritrovarmi in due stati:
    * sono finite le palline
    * ci sono altre palline ==> ritorno a `noQuarter`

Le frecce che ci sono però sono cose che il cliente potrebbe fare anche quando non ci sono le condizioni per farlo (es inserire la monetina quando ce n'è già una). Sono i miei eventi

* Frecce = cambiamento di stato
* etichetta freccia = vento


Se mantengo nella mia impkementazione i concetti di **evento** **traniszione** e **stato** se poi devo implementare nuovi stati posso farlo, altrimenti diventa difficile.

### Codice 

#### Brutto

senza usare il pattern State

```java
 public class GumballMachine { ???????????''''''''''''
  
```

# Flyweight

> uqnado una classe può essere usato pee creare altre istanze virtuali

*es* software di disegno ho l'oggetto albero che è un cerchio la cui raggio dipende dalla età dell'albero.

ho un sacco di istanze virtulali di un unica istanza che possono essere 

# Command {comportamentale}

è comportamentale e infatti il diagramma degli stati ci darà poche info inizialmente

> è l'equivalente delle `callback` nell'OO
>
> quando ho bisogno di scollegare ciò che viene chiamato e ciò che chiamiamo. Quando ho una lista di chiamate.




****