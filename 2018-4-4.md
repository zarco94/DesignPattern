---
author: Gabriele Zarcone
date: 4 aprile 2018
title: Object Orientation
---
---------------------------------------------

Decorator Pattern
===
voglio distinguere tra componente decorabile e oggetto decoratore

* uno è l'oggetto vero

* l'altro è quello che definisce la decorazione

il problema è che l'oggetto da decorare potrebbe già avevre una decorazione. Se voglio una pizza capperi e olive ho più oggetti:

* l'oggetto pizza

* l'oggetto capperi decorazione

* l'oggetto olive decorazione

Concret component con le sue funzioni
Decorator capace di decorare un concret component

non posso farli interagire tra di loro vuol dire che per ogni pizza il decoratore deve avere una aggregazione specifica, per qualsisi base di pizza. Li faccio interagire tramite una interfaccia

è ricorsivo perchè il decorator può essere un componente

## Cardinalità

un *Decoratore* può decorare **una sola istanza** di un Componente
La pizza può essere decorata solo dalle olive o solo dai capperi, se volgio aggiungere i capperi insieme alle olive, i capperi decorano le olive e non i capperi

non è uno ad uno perchè dovrei sempre decorare sia gli oggetti che i decorator ( non possono non avere decorazioni). Un oggetto componente deve sempre essere decorato da qualcuno

* un decorator decora un solo component

* un component è decorato da 0 o 1 decorator

**errore sulla slide**

decorator ha un aggregazione con l'interfaccia che è indicata sia dalla freccia che dall'attributo. Non mi serve metterli tutti e due. Non capiso se sono entrambi la stessa una cosa o due cose diverse. Se voglio forzare a creare un a aggregazione come attributo scrivo solo l'attributo e non la freccia

`sample operation` viene definito nell'interfaccia, nel component e nel decorator.

## Esempio Caffè  
questo `foto`sono tre componenti che aggregano uno l'altro

`whip` detto visione a cipolla  
parla del caffè: 

* chiamo la funzione `calcolaCosto()` di un caffè scuro con panna

la panna, il cacao sono tutte decorazioni del caffè 

quindi chiamo `calcolaCosto()` su panna che chiama `calcolaCosto()` sulla sua decorazione (cioccolato) che chiama `calcolaCosto()` su caffè. Quando arrivo a uno senza decoratore vengono calcolati tutti i costi partendo dal più interno.

### Implementazioni
due metodi uno calcola il costo e l'altro la descrizione
#### Metodo Statico (con attributo)

* ho una classe asratta Beverage che ha un `getDescription` già impementato (poteva anche essere una interfaccia)

* Espresso estende Beverageho un prezzo base per le diverse tipologie di caffè

* classe astratta `condimentDecorator()` che non fa nulla

#### Dinamico (con metodi)

mai usare un `double` per i soldi, non ritornano le somme altrimenti

il decorator viene usato  in moltre classi java.  
Ognuno aggunge un comportamento diverso su come si deve comportare un certo metodo 

## Osservazioni

il debugging sarà più complicato ma i vari oggetti sono più snelli 

Viene usato in `InputStream`: decoro l'input d'ingresso con delle caratteristiche. Come è fatto l'input o come sono fatti gli ingressi. Ho degli oggetti base di inputstream che però hanno delle caratteristiche da aggiungerci (lowerCase, buffered ecc.....)

L'ereditarietà non sempre è la soluzione migliore. La composizione è molto potente e posso usarla al suo posto. Per composizione si intende usare classi compontenti relative ad un interfaccia (????)

## La saga delle anatre

quando uso l'ereditarietà o il controllo su chi eredito. Posso decidere da chi eredito, sono io che lo decido. Il padre però non ha alcun potere sul figlio, non può decidere chi lo può estendere. Chiunque può scrivere una classe che estende la mia classe. 

Mentre con la composizione ho il controllo, l'interfaccia controlla i metodi che deve avere chi lo implementa. Con l'interfaccia ho il controllo sul figlio. 

serve per fare un simulatore delle anatre:

- classe base = DUCK  

- poi ci sono delle specializzazioni = specificano il 

colore diverso delle diverse anatre  

voglio aggiungere il metodo `fly` pechè le anatre sanno anche volare. Dovrei aggiungere un metodo alla classe Duck.
è pericoloso perwò modificare la classe Duck, perchè non ho controloo su chi eredita da me, chiunque può ereditare da me (non so chi lo fa). 

magari un altro sviluppatore aveva fatto anche la *papaerella di gomma* che ereditava da Duck, se modifico la classe duck anche le paperelle di gomma iniziano a volare. 

Quindi è pericoloso cambiare una classe da cui altri classi ereditano.

Possibili soluzioni:

- **override**:     tolgo il metodo fly svuotandolo nella papaerella di gomma -> violo il principio di LIskov -> **NON VA BENE**

- **realizzo con interfacce**:creo un'interfaccia con il metodo `fly` e solo le anatre che volano lo implementano. Così però devo implementare il metodo fly in tutte le classi che implemetnano l'interfaccia, perchè l'interfaccia non implementa nulla. 

- **delega**(strategy pattern): rimappo usando uno strategy pateern. 

## Design principles:

* Quando si progetta devi stare attento a quali sono gli aspetti e le parti che stanno cambiando e tenerle d'occhio in maniera conscia. Devo accorgermi di quali sono i punti di dinamicità. Se continuo a cambiare una parte di comportamneto del mio codice, allora forse è meglio estrarre quella parte con il refactoring. Bisogna separare le parti che continuano a variare.
*  Dependency inversion: programma verso interfacce e non implementazioni

Se ho dei modi di fare quack e dei modi di volare, allora è meglio se 

# Strategy Pattern
 

- tengo in una classe l'aspetto caldo e tutte le parti fredde in una classe separata

- lavora veros astrazioni e non cose concrete

`2` 11'45'' 

la gang of four lo presenta coe una maniera per definire una serie di algoritmi differenti tra di loro, incapsularli e renderli intercambiabili fra di loro

**es**: andare a capo di word (2)15'10''

**es** in JSWING per esempio è il *Jcomponent*: i componenti possono essere inquadrati in diversi tipi di bordo. Io so già il concetto di bordo, non è più una decorazione qualunque, è un bordo.


![Image of Yaktocat](https://image.freepik.com/free-vector/colorful-watercolor-triangles-pattern_23-2147662863.jpg)

# Adapter pattern

prova

> prova


> questa è una 
> citazione  
> lunga  
> lunga  
> lungaaaaa.......  


[ ] prova  
[x] prova

|tables| prova |
|------|-------|
|1     |  2    |
|3      | 5|
|1  |1|


```java 
import java.util;
public static void main(){
    new Prova = 10;
}
```


[markdown](https://it.wikipedia.org/wiki/Markdown)


